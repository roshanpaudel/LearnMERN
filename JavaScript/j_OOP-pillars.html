<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // ============================================
      // 1. ENCAPSULATION — Keep data private & secure
      // ============================================
      class BankAccount {
        #balance = 0; // Private field using #

        constructor(owner) {
          this.owner = owner; // Public property
        }

        deposit(amount) {
          if (amount > 0) this.#balance += amount;
        }

        withdraw(amount) {
          if (amount <= this.#balance) {
            this.#balance -= amount;
          } else {
            console.log("Insufficient funds");
          }
        }

        getBalance() {
          return this.#balance;
        }
      }

      const account = new BankAccount("Alice");
      account.deposit(500);
      account.withdraw(200);
      console.log("1. Encapsulation - Balance:", account.getBalance());
      // Output: 300
      // account.#balance; // ❌ Error: private field is not accessible outside

      // ============================================
      // 2. ABSTRACTION — Hide internal complexity
      // ============================================
      class CoffeeMachine {
        constructor() {
          this.waterLevel = 0;
        }

        addWater(amount) {
          this.waterLevel += amount;
        }

        makeCoffee() {
          if (this.waterLevel >= 1) {
            this.#heatWater();
            console.log("2. Abstraction - ☕ Coffee is ready");
            this.waterLevel -= 1;
          } else {
            console.log("Add water first!");
          }
        }

        // Hidden internal logic (abstraction)
        #heatWater() {
          console.log("Heating water...");
        }
      }

      const myMachine = new CoffeeMachine();
      myMachine.addWater(2);
      myMachine.makeCoffee();
      // Output:
      // Heating water...
      // 2. Abstraction - ☕ Coffee is ready

      // ============================================
      // 3. INHERITANCE — Child class gets from parent
      // ============================================
      class Animal {
        constructor(name) {
          this.name = name;
        }

        speak() {
          console.log(`3. Inheritance - ${this.name} makes a noise.`);
        }
      }

      class Dog extends Animal {
        constructor(name, breed) {
          super(name); // Call parent constructor
          this.breed = breed;
        }

        speak() {
          console.log(`3. Inheritance - ${this.name} barks!`);
        }
      }

      const myDog = new Dog("Buddy", "Golden Retriever");
      myDog.speak();
      // Output: Buddy barks!

      // ============================================
      // 4. POLYMORPHISM — One method, different behavior
      // ============================================
      const animals = [
        new Animal("Generic Animal"),
        new Dog("Max", "Labrador")
      ];

      animals.forEach(animal => animal.speak());
      // Output:
      // 3. Inheritance - Generic Animal makes a noise.
      // 3. Inheritance - Max barks!

      // Polymorphism allows Dog to override Animal's speak() method
      .
    </script>
  </body>
</html>
